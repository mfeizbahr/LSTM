# -*- coding: utf-8 -*-
"""LSTM J17.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-5jJmLtFyzNNE-jJZLCc9VeWfUmsGc8t
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM


# mount the Google Drive
from google.colab import drive
drive.mount('/content/drive')

# read the CSV file into a pandas DataFrame
url = 'https://drive.google.com/file/d/1y2m-kcxD21Djz3QL7yleomcXyyAK3WtH/view?usp=sharing'
file_id = url.split('/')[-2]
download_url = 'https://drive.google.com/uc?id=' + file_id
df = pd.read_csv(download_url)

from sklearn.model_selection import train_test_split

# Separate features and target variable
X = df.drop('Elevation', axis=1)
y = df['Elevation']

# Split data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
df.head()

print('Number of rows in X_train:', X_train.shape[0])
print('Number of rows in X_test:', X_test.shape[0])
print('Number of rows in y_train:', y_train.shape[0])
print('Number of rows in y_test:', y_test.shape[0])

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

model = Sequential()
model.add(LSTM(64, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(LSTM(32, return_sequences=True))
model.add(LSTM(16))
model.add(Dense(1))

model.compile(loss='mean_squared_error', optimizer='adam')

import plotly.graph_objects as go

# create a trace for the time series plot with reversed x and y arrays
trace = go.Scatter(x=df['Date'][::-1], y=df['Elevation'][::-1], mode='lines')

# create a layout for the plot
layout = go.Layout(title='Elevation Over Time', xaxis=dict(title='Date'), yaxis=dict(title='Elevation'))

# create a figure and add the trace and layout
fig = go.Figure(data=[trace], layout=layout)

# display the figure
fig.show()

# split the data into training and testing sets
train_size = int(len(df) * 0.8)
train_data = df[:train_size]
test_data = df[train_size:]

# scale the data using a MinMaxScaler
scaler = MinMaxScaler()
train_scaled = scaler.fit_transform(train_data[['Elevation']])
test_scaled = scaler.transform(test_data[['Elevation']])

# convert the data into a format that can be used for training and testing the LSTM model
def create_dataset(X, y, time_steps=1):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        Xs.append(X[i:(i + time_steps), 0])
        ys.append(y[i + time_steps])
    return np.array(Xs), np.array(ys)

time_steps = 30

X_train, y_train = create_dataset(train_scaled, train_scaled, time_steps)
X_test, y_test = create_dataset(test_scaled, test_scaled, time_steps)

# define the LSTM model
model = Sequential([
    LSTM(50, input_shape=(X_train.shape[1], 1)),
    Dense(1)
])

# compile the model
model.compile(loss='mean_squared_error', optimizer='adam')

# train the model
history = model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))

# use the trained model to predict the test data
y_pred = model.predict(X_test)

# invert the scaling of the predicted and actual values
y_pred_inv = scaler.inverse_transform(y_pred)
y_test_inv = scaler.inverse_transform(y_test)

# print the predicted and actual values for the last 10 time steps in the test set
print('Predicted:\n', y_pred_inv[-10:])
print('Actual:\n', y_test_inv[-10:])

import plotly.graph_objects as go

# make predictions on test data
y_pred = model.predict(X_test)

# create a figure with two traces
fig = go.Figure()

# add the actual values trace
fig.add_trace(
    go.Scatter(x=df['Date'], y=y_test.reshape(-1), name='Actual')
)

# add the predicted values trace
fig.add_trace(
    go.Scatter(x=df['Date'], y=y_pred.reshape(-1), name='Predicted')
)

# update the layout
fig.update_layout(
    title='Actual vs. Predicted',
    xaxis_title='Date',
    yaxis_title='Elevation',
    template='plotly_white'
)

# show the plot
fig.show()

import plotly.graph_objects as go

# make predictions on test data
y_pred = model.predict(X_test)

# create a figure with two traces
fig = go.Figure()



# add the actual values trace
fig.add_trace(
    go.Scatter(x=train_data['Date'], y=train_data['Elevation'], name='Train')
)

# add the predicted values trace
fig.add_trace(
    go.Scatter(x=test_data['Date'], y=y_pred.reshape(-1), name='Predicted')
)



# update the layout
fig.update_layout(
    title='Actual vs. Predicted',
    xaxis_title='Date',
    yaxis_title='Discharge',
    template='plotly_white'
)

# show the plot
fig.show()

# get the training and validation loss from the history object
train_loss = history.history['loss']
val_loss = history.history['val_loss']

# plot the loss curves
plt.plot(train_loss, label='Training loss')
plt.plot(val_loss, label='Validation loss')
plt.legend()
plt.show()