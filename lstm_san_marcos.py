# -*- coding: utf-8 -*-
"""LSTM San Marcos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/174S3zRswWD_uks1_7z69C1Aa2zJ33VuN
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM

# mount the Google Drive
from google.colab import drive
drive.mount('/content/drive')

# read the CSV file into a pandas DataFrame
file_path = '/content/drive/My Drive/Colab Notebooks/San Marcos.csv'
 
df = pd.read_csv(file_path)

df.head()

# interpolate missing values in Discharge column
df['Discharge'] = df['Discharge'].interpolate()

from sklearn.model_selection import train_test_split

# Separate features and target variable
X = df.drop('Discharge', axis=1)
y = df['Discharge']

# Split data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print('Number of rows in X_train:', X_train.shape[0])
print('Number of rows in X_test:', X_test.shape[0])
print('Number of rows in y_train:', y_train.shape[0])
print('Number of rows in y_test:', y_test.shape[0])

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
 

model = Sequential()
model.add(LSTM(64, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(LSTM(32, return_sequences=True))
model.add(LSTM(16))
model.add(Dense(1))

model.compile(loss='mean_squared_error', optimizer='adam')

import plotly.graph_objects as go

# create a trace for the time series plot with reversed x and y arrays
trace = go.Scatter(x=df['Date'][::-1], y=df['Discharge'][::-1], mode='lines')

# create a layout for the plot
layout = go.Layout(title='Elevation Over Time', xaxis=dict(title='Date'), yaxis=dict(title='Discharge'))

# create a figure and add the trace and layout
fig = go.Figure(data=[trace], layout=layout)

# display the figure
fig.show()

# split the data into training and testing sets
train_size = int(len(df) * 0.8)
train_data = df[:train_size]
test_data = df[train_size:]
 
# scale the data using a MinMaxScaler
scaler = MinMaxScaler()
train_scaled = scaler.fit_transform(train_data[['Discharge']])
test_scaled = scaler.transform(test_data[['Discharge']])

# convert the data into a format that can be used for training and testing the LSTM model
def create_dataset(X, y, time_steps=1):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        Xs.append(X[i:(i + time_steps), 0])
        ys.append(y[i + time_steps])
    return np.array(Xs), np.array(ys)

time_steps = 60

X_train, y_train = create_dataset(train_scaled, train_scaled, time_steps)
X_test, y_test = create_dataset(test_scaled, test_scaled, time_steps)

 
# define the LSTM model
model = Sequential([
    LSTM(50, input_shape=(X_train.shape[1], 1)),
    Dense(1)
])

# compile the model
model.compile(loss='mean_squared_error', optimizer='adam')

# train the model
history = model.fit(X_train, y_train, epochs=25, batch_size=32, validation_data=(X_test, y_test))

# use the trained model to predict the test data
y_pred = model.predict(X_test)

# invert the scaling of the predicted and actual values
y_pred_inv = scaler.inverse_transform(y_pred)
y_test_inv = scaler.inverse_transform(y_test)



# print the number of predicted rows
print('Number of predicted rows:', y_pred_inv.shape[0])
print('Number of test data rows:', y_test_inv.shape[0])

# print the predicted and actual values for the last 10 time steps in the test set
print('Predicted:\n', y_pred_inv[-10:])
print('Actual:\n', y_test_inv[-10:])

import plotly.graph_objects as go

# make predictions on test data
y_pred = model.predict(X_test)

# create a figure with two traces
fig = go.Figure()

# add the actual values trace
fig.add_trace(
    go.Scatter(x=df['Date'], y=y_test.reshape(-1), name='Aoriginal testing data')
)

# add the predicted values trace
fig.add_trace(
    go.Scatter(x=df['Date'], y=y_pred.reshape(-1), name='Predicted')
)

# update the layout
fig.update_layout(
    title='Actual vs. Predicted',
    xaxis_title='Date',
    yaxis_title='Discharge',
    template='plotly_white'
)

# show the plot
fig.show()

import plotly.graph_objects as go

# make predictions on test data
y_pred = model.predict(X_test)

# create a figure with two traces
fig = go.Figure()


# add the actual values trace
fig.add_trace(
    go.Scatter(x=train_data['Date'], y=train_data['Discharge'], name='Train')
)

# add the predicted values trace
fig.add_trace(
    go.Scatter(x=test_data['Date'], y=y_pred.reshape(-1)*500, name='Predicted')
)


# update the layout
fig.update_layout(
    title='Actual vs. Predicted',
    xaxis_title='Date',
    yaxis_title='Discharge',
    template='plotly_white'
)

# show the plot
fig.show()

# get the training and validation loss from the history object
train_loss = history.history['loss']
val_loss = history.history['val_loss']

# plot the loss curves
plt.plot(train_loss, label='Training loss')
plt.plot(val_loss, label='Validation loss')
plt.legend()
plt.show()

# calculate rolling mean with window of 10
df['Rolling Mean'] = df['Discharge'].rolling(window=100).mean()

# plot original data and rolling mean
fig = go.Figure()
fig.add_trace(go.Scatter(x=df['Date'], y=df['Discharge'], name='Discharge'))
fig.add_trace(go.Scatter(x=df['Date'], y=df['Rolling Mean'], name='Rolling Mean'))
fig.update_layout(title='Discharge with Rolling Mean')
fig.show()